二叉树：每个节点最多有两个子节点。
~~~
	  10
	/    \
	9    20
			/   \
	   15   35
~~~

二叉树的特点：
1. 每个节点最多有两个子树，节点的度最大为2；
2. 左子树和右子树是有顺序的，次序不能颠倒；
3. 即使某节点只有一个子树，也要区分左右子树；

二叉树的操作：
1. 创建二叉树；
2. 遍历二叉树；
	a. 先序遍历：先访问根节点，然后访问左节点，最后访问右节点（根->左->右）10->9->20->15->35
	b. 中序遍历：先访问左节点，然后访问根节点，最后访问右节点（左->根->右）9->10->15->20->35
	c. 后序遍历：先访问左节点，然后访问右节点，最后访问根节点（左->右->根）9->15->35->20->10
3. 查询树的深度；
4. 查询树的最大值；

通过先序和中序/中序和后序我们可以还原出原始的二叉树，但是通过先序和后序是无法还原出原始的二叉树的。（？）

特殊的二叉树：
1. 斜树；
所有的节点都只有左子树（左斜树），后者只有右子树（右斜树）。

2. 满二叉树；
所有的分支节点都存在左子树和右子树，并且所有的叶子结点都在同一层上。

满二叉树的特点：
a. 叶子只能出现在最下一层；
b. 非叶子节点度一定是2；
c. 在同样深度的二叉树中，满二叉树的节点个数最多，叶子树最多；

3. 完全二叉树；
对一棵具有n个结点的二叉树按层序排号，如果编号为i的结点与同样深度的满二叉树编号为i结点在二叉树中位置完全相同，就是完全二叉树。
满二叉树必须是完全二叉树，反过来不一定成立。

完全二叉树特点：
a. 叶子节点只能出现在最下一层（满二叉树继承而来）；
b. 最下层叶子节点一定集中在左 部连续位置；
c. 倒数第二层，如有叶子节点，一定出现在右部连续位置；
d. 同样节点树的二叉树，完全二叉树的深度最小（满二叉树也是对的）；

二叉查找树(binary search tree)：
当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大。

二叉树题目:
(01) 求二叉树的最大深度；
(02) 求二叉树的最小深度；
(03) 求二叉树中节点的个数；
(04) 求二叉树中叶子节点的个数；
(05) 求二叉树中第k层节点的个数；
(06) 判断二叉树是否是平衡二叉树；
(07) 判断二叉树是否是完全二叉树；
(08) 判断两个二叉树是否完全相同；
(09) 判断两个二叉树是否互为镜像；
(10) 翻转二叉树/镜像二叉树；
(11) 求两个二叉树的最低公共祖先节点；
(12) 二叉树的前序遍历；
(13) 二叉树的中序遍历；
(14) 二叉树的后序遍历；
(15) 构造二叉树（前序遍历和中序遍历/后序遍历和中序遍历）；
(16) 二叉树中插入/删除节点；
(17) 输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径；
(18) 二叉树的搜索区间；
(19) 二叉树的层次遍历；
(20) 二叉树内两个节点的最长距离；
(21) 不同的二叉树；
(22) 判断二叉树是否是合法的二叉查找树（BST）；